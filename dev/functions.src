function migr_since() {
  git whatchanged ${1-master}..HEAD | grep "db/migrate"
}
add_function_help "migr_since" "Migrations created since commit{1}. Defaults to master"

function specg() {
  find . | fgrep "spec.rb" | grep $1 | xargs bin/rspec
}
add_function_help "specg" "Run specs matching pattern{1}"

function hp() {
  git push $1 HEAD:master $2
}
add_function_help "hp" "Push to Heroku Remote{1}. Use -f at the end to force push" 

function ha() {
  heroku addons:open $1 -a $2
}
add_function_help "ha" "Open Heroku Addon{1} on application{2}"

function webserver() {
  ruby -run -e httpd ${1-.} -p ${2-9090}
}
add_function_help "webserver" "Expose directory{1} with a web server at port 9090{2}"

# PNPM
function pb() {
  pnpm --filter "$1" build
}
add_function_help "pb" "Build pnpm package{1}"

function pbchan() {
  pnpm --filter "[main]" build
}
add_function_help "pbchan" "Build pnpm packages that changed since main@HEAD"

function sqs-sizes() {
  for q in $(aws --endpoint-url=http://localhost:4566 sqs list-queues --query 'QueueUrls[]' --output text); do
    echo "Queue: $q"
    aws --endpoint-url=http://localhost:4566 sqs get-queue-attributes \
      --queue-url $q \
      --attribute-names ApproximateNumberOfMessages ApproximateNumberOfMessagesNotVisible ApproximateNumberOfMessagesDelayed
  done
}
add_function_help "sqs-sizes" "List queues with their sizes"

function sqs-list() {
  aws --endpoint-url=http://localhost:4566 sqs list-queues
}
add_function_help "sqs-list" "List queues"

function sqs-peek() {
  local QUEUE_URL=$1
  local ENDPOINT=${ENDPOINT:-http://localhost:4566}  # change if using real AWS
  local VIS=${VIS:-30}                                # small non-zero to avoid repeats
  local MAX_EMPTY=${MAX_EMPTY:-2}                     # stop after N empty polls
  local MAX_PAGES=${MAX_PAGES:-0}                     # 0 = unlimited

  if [ -z "$QUEUE_URL" ]; then
    echo "Usage: sqs-peek <queue-url>"
    return 1
  fi
  command -v aws >/dev/null || { echo "Requires aws CLI"; return 1; }
  command -v jq  >/dev/null || { echo "Requires jq"; return 1; }

  echo "Peeking from: $QUEUE_URL (visibility-timeout=${VIS}s)"
  local empty=0 page=1 RESP COUNT

  while :; do
    RESP=$(aws --endpoint-url="$ENDPOINT" sqs receive-message \
      --queue-url "$QUEUE_URL" \
      --max-number-of-messages 10 \
      --visibility-timeout "$VIS" \
      --wait-time-seconds 0 \
      --output json 2>/dev/null) || RESP=""

    COUNT=$(jq -r '((.Messages // []) | length) // 0' 2>/dev/null <<<"$RESP")
    COUNT=${COUNT:-0}

    if [ "$COUNT" -eq 0 ] 2>/dev/null; then
      empty=$((empty+1))
      if [ "$empty" -ge "$MAX_EMPTY" ] 2>/dev/null; then
        echo "Done (no more messages)."
        break
      fi
      continue
    fi

    empty=0
    echo "---- Page $page ----"
    jq -r '.Messages[] | (.MessageId // "") + " | " + (.Body // "") + "\n"' <<<"$RESP"
    page=$((page+1))

    if [ "$MAX_PAGES" -gt 0 ] 2>/dev/null && [ "$page" -gt "$MAX_PAGES" ] 2>/dev/null; then
      echo "Reached MAX_PAGES=$MAX_PAGES, stopping."
      break
    fi
  done
}
add_function_help "sqs-peek" "Peek all messages from a queue"

function sqs-purge() {
  if [ -z "$1" ]; then
    echo "Usage: purge-local-queue <queue-name>"
    return 1
  fi
  
  local queue_name=$1
  local queue_url=$(aws --endpoint-url=http://localhost:4566 sqs get-queue-url --queue-name "$queue_name" --query 'QueueUrl' --output text 2>/dev/null)
  
  if [ -z "$queue_url" ]; then
    echo "Error: Queue '$queue_name' not found"
    return 1
  fi
  
  echo "Purging queue: $queue_name"
  echo "Queue URL: $queue_url"
  aws --endpoint-url=http://localhost:4566 sqs purge-queue --queue-url "$queue_url"
  
  if [ $? -eq 0 ]; then
    echo "✓ Queue purged successfully"
  else
    echo "✗ Failed to purge queue"
    return 1
  fi
}
add_function_help "sqs-purge" "Purge all messages from a queue by name{1}"
